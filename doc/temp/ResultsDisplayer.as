package raymulticast
{
	import flash.geom.Point;
	import flash.display.Sprite;
	import flash.display.Shape;
	import flash.text.TextField;
	import flash.events.Event;
	import flash.events.KeyboardEvent;
	import flash.events.MouseEvent;
	import flash.geom.Transform;
	import flash.geom.ColorTransform;
	/**
	 * <p>A ResultsDisplayer object provides views of the results generated by an 
	 * {@link AllRaysCaster} object. Provided here for utility, and includes 
	 * a sample main method for demonstration.</p> 
	 * 
	 */
	public class ResultsDisplayer extends Sprite
	{
		
		private const RAND:Function = Math.random; 
		private const NUM_OBSTRUCTIONS:int = 20;
		private const WORLD_SIZE:int = 13; //world's width and height dimension, i.e. sqrt of total num tiles.
		
		private var mapWidth:int; //counted in number of tiles
		private var tileSize:int;
		private var world:World;
		private var resultData:Array; //(*** was of type RayData[][] ***)
		private var origin:Point;
		private var caster:AllRaysCaster;
		private var isCycling:Boolean = false;
		private var busyRaycasting:Boolean = false;
		private var locGrid:Array;
		private var locCanvas:Sprite;

		public function ResultsDisplayer()
		{
			//instantiate and add drawing canvas to display list
			addChild(locCanvas = new Sprite());
			
			//ensure UI components are enabled
			buttonToggleExecution.enabled = stepperMapWidth.enabled = true;
			
			//setup UI event listeners
			buttonToggleExecution.addEventListener(MouseEvent.CLICK, onButtonClicked);
			
			stepperFPS.addEventListener(Event.CHANGE, onFrameRateChanged);
			//set initial frame rate
			
		}
		
		private function initialise()
		{
			mapWidth = stepperMapWidth.value;
			tileSize = stage.width / mapWidth;
			
			//Ensure we have a correctly sized reference grid for
			//all the locations to populate
			locGrid = new Array(mapWidth);
			for (var i:int = 0; i < mapWidth; i++)
			{
				locGrid[i] = new Array();
			}
			
			//Set up a world which will hold our obstructions
			world = new SimpleWorld(mapWidth);
			for(i = 0; i < NUM_OBSTRUCTIONS; i++)
			{
				world.addObstructionAt( int(RAND() * mapWidth), int(RAND() * mapWidth) );
			}
			
			//randomise the origin, and draw it - it will never be part
			//of the perimeter and so would be skipped in drawTiles()
			origin = new Point(int(RAND() * mapWidth), int(RAND() * mapWidth));
			drawOriginTile();
			
			//Set up the raycaster object
			caster = new AllRaysCaster(world, origin.x, origin.y);

			//Set up dummy initial result data (to get things rolling)
			resultData = new Array(new RayData(0, 0));//caster.castRays();

			//inform as when the algorithm has run it's full course
			caster.addEventListener(Event.COMPLETE, onRaycastingComplete);
		}
		
		private function onAddedToStage(e:Event):void
		{
			stage.frameRate = stepperFPS.value;
			stage.addEventListener(KeyboardEvent.KEY_DOWN, checkKeys);
		}
		
		private function onButtonClicked(e:MouseEvent):void
		{
			toggleCycling();
			
			if (!busyRaycasting) 
			{
				busyRaycasting = true;
				stepperMapWidth.enabled = false;
				cleanUpStage();
				initialise();
			}
		}
		
		
		private function onRaycastingComplete(e:Event):void
		{
			busyRaycasting = false;
			stepperMapWidth.enabled = true;
			toggleCycling();
			buttonToggleExecution.label = 'Commence new scan';
			traceResults();
		}
		
		private function onFrameRateChanged(e:Event):void
		{
			stage.frameRate = stepperFPS.value;
		}
		
		private function toggleCycling():void
		{
			if (!isCycling)
			{
				buttonToggleExecution.label = 'Halt scan';
				addEventListener(Event.ENTER_FRAME, cycle);
			}
			else
			{
				buttonToggleExecution.label = 'Commence scan';
				removeEventListener(Event.ENTER_FRAME, cycle);
			}
			isCycling = !isCycling;
		}
		
		private function cycle(e:Event):void
		{
			resultData = caster.castRays();
			drawTiles();
		}
		
		private function cleanUpStage():void
		{
			while (locCanvas.numChildren > 0)
        	{
				locCanvas.removeChildAt(0);
        	}
		}
		
		private function drawOriginTile():void
		{
			//create and position location/tile
			var rayLoc:RayLocation = locCanvas.addChild(new RayLocation()) as RayLocation;
			rayLoc.x = origin.x * tileSize;
			rayLoc.y = origin.y * tileSize;
			rayLoc.height = rayLoc.width = tileSize;
			
			//set all critical textual info on location/tile
			rayLoc.xLoc.text = '0';
			rayLoc.yLoc.text = '0';
			
			//create, affect and apply colour transform
			var trans:Transform = new Transform(rayLoc.bg);
			var colorTrans:ColorTransform = new ColorTransform(0,1,1,1,0,0,0,0);
			trans.colorTransform = colorTrans;
		}
		
		private function drawTiles():void
		{
			var currentData:RayData;
			for(var mapY:int = 0; mapY < mapWidth; mapY++)
			{
				for(var mapX:int = 0; mapX < mapWidth; mapX++)
				{
					currentData = resultData[mapX][mapY];
					if (currentData != null) 
					{
						//prep local vars
						var rayLoc:RayLocation;
						var redMult, blueMult, greenMult:Number;
						redMult = greenMult = blueMult = 0;
						
						//set colour dependant on location type
						if ((mapX == origin.x) && (mapY == origin.y ))
							blueMult = 1;
						else if (world.hasObstructionAt(mapX, mapY))
							redMult = 1;
						else if (currentData.ignore)
							redMult = greenMult = blueMult = 0.5;
						else if (currentData.obscured)
							greenMult = blueMult = 0.8*(redMult = 1);
						else if (currentData.added)
							greenMult = 1;
						
						//make a new location (tile) if none exists, set position, give mouseover action
						if (locGrid[mapX][mapY] == null)
						{
							rayLoc = locCanvas.addChild(new RayLocation()) as RayLocation;
							rayLoc.x = mapX * tileSize;
							rayLoc.y = mapY * tileSize;
							rayLoc.height = rayLoc.width = tileSize;

						}
						//else use location already in grid
						else rayLoc = locGrid[mapX][mapY];
						
						//set all critical textual info on location/tile
						rayLoc.xLoc.text = currentData.xLoc.toString();
						rayLoc.yLoc.text = currentData.yLoc.toString();
						rayLoc.xObsc.text = currentData.xObsc.toString();
						rayLoc.yObsc.text = currentData.yObsc.toString();
						rayLoc.xErrObsc.text = currentData.xErrObsc.toString();
						rayLoc.yErrObsc.text = currentData.yErrObsc.toString();
						
						//create, affect and apply colour transform
						var trans:Transform = new Transform(rayLoc.bg);
						var colorTrans:ColorTransform = new ColorTransform(redMult,greenMult,blueMult,1,0,0,0,0);
						trans.colorTransform = colorTrans;

						//add the new location to our reference grid, if it's empty at this location.
						if (locGrid[mapX][mapY] == null) 
							locGrid[mapX][mapY] = rayLoc;
					}
				}
			}
		}
		
		public function traceResults():void
		{
			var out:String = '';
			for(var y:int = 0; y < world.getSize(); y++)
			{
				for(var x:int = 0; x < world.getSize(); x++)
				{
					if(world.hasObstructionAt(x, y)) out += "W ";
					else if((x == origin.x) && (y == origin.y)) out += "V ";
					else if(resultData[x][y] == null) out += ". ";
					else out += resultData[x][y].toChar() + " ";
				}
				out += "\n";
			}
			trace(out);
		}
		
		private function checkKeys(e:KeyboardEvent):void
		{
			trace("<Key pressed, keycode is "+e.keyCode+">");
			if (!busyRaycasting) //during algorithm run
			{
				if (e.keyCode == 48) initialise();
			}
			else //between algorithm runs
			{
				if (e.keyCode == 32) toggleCycling();
			}
		}
		
	}
}